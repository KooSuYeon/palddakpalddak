[
    "Open-Source AI Cookbook documentation\n\t\t\t",
    "Building RAG with Custom Unstructured Data",
    "and get access to the augmented documentation experience\n\t\t",
    "to get started",
    "",
    "Authored by: Maria Khalusova",
    "If you’re new to RAG, please explore the basics of RAG first in this other notebook, and then come back here to learn about building RAG with custom data.",
    "Whether you’re building your own RAG-based personal assistant, a pet project, or an enterprise RAG system, you will quickly discover that a lot of important knowledge is stored in various formats like PDFs, emails, Markdown files, PowerPoint presentations, HTML pages, Word documents, and so on.",
    "How do you preprocess all of this data in a way that you can use it for RAG?\nIn this quick tutorial, you’ll learn how to build a RAG system that will incorporate data from multiple data types. You’ll use Unstructured for data preprocessing, open-source models from Hugging Face Hub for embeddings and text generation, ChromaDB as a vector store, and LangChain for bringing everything together.",
    "Let’s go! We’ll begin by installing the required dependencies:",
    "Next, let’s get a mix of documents. Suppose, I want to build a RAG system that’ll help me manage pests in my garden. For this purpose, I’ll use diverse documents that cover the topic of IPM (integrated pest management):",
    "Feel free to use your own documents for your topic of choice from the list of document types supported by Unstructured: .eml, .html, .md, .msg, .rst, .rtf, .txt, .xml, .png, .jpg, .jpeg, .tiff, .bmp, .heic, .csv, .doc, .docx, .epub, .odt, .pdf, .ppt, .pptx, .tsv, .xlsx.",
    "You can use the Unstructured library to preprocess documents one by one, and write your own script to walk through a directory, but it’s easier to use a Local source connector to ingest all documents in a given directory. Unstructured can ingest documents from local directories, S3 buckets, blob storage, SFTP, and many other places your documents might be stored in. The ingestion from those sources will be very similar differing mostly in authentication options.\nHere you’ll use Local source connector, but feel free to explore other options in the Unstructured documentation.",
    "Optionally, you can also choose a destination for the processed documents - this could be MongoDB, Pinecone, Weaviate, etc. In this notebook, we’ll keep everything local.",
    "Let’s take a closer look at the configs that we have here.",
    "ProcessorConfig controls various aspects of the processing pipeline, including output locations, number of workers, error handling behavior, logging verbosity and more. The only mandatory parameter here is the output_dir - the local directory where you want to store the outputs.",
    "ReadConfig can be used to customize the data reading process for different scenarios, such as re-downloading data, preserving downloaded files, or limiting the number of documents processed. In most cases the default ReadConfig will work.",
    "In the PartitionConfig you can choose whether to partition the documents locally or via API. This example uses API, and for this reason requires Unstructured API key. You can get yours here.  The free Unstructured API is capped at 1000 pages, and offers better OCR models for image-based documents than a local installation of Unstructured.\nIf you remove these two parameters, the documents will be processed locally, but you may need to install additional dependencies if the documents require OCR and/or document understanding models. Namely, you may need to install poppler and tesseract in this case, which you can get with brew:",
    "If you’re on Windows, you can find alternative installation instructions in the Unstructured docs.",
    "Finally, in the SimpleLocalConfig you need to specify where your original documents reside, and whether you want to walk through the directory recursively.",
    "Once the documents are processed you’ll find 4 json files in the local-ingest-output directory, one per document that was processed.\nUnstructured partitions all types of documents in a uniform manner, and returns json with document elements.",
    "Document elements have a type, e.g. NarrativeText, Title, or Table, they contain the extracted text, and metadata that Unstructured was able to obtain. Some metadata is common for all elements, such as filename of the document the element is from. Other metadata depends on file type or element type. For example, a Table element will contain table’s representation as html in the metadata, and metadata for emails will contain information about senders and recipients.",
    "Let’s import element objects from these json files.",
    "Now that that you have extracted the elements from the documents, you can chunk them to fit the context window of the embeddings model.",
    "If you are familiar with chunking methods that split long text documents into smaller chunks, you’ll notice that Unstructured’s chunking methods slightly differ, since the partitioning step already divides an entire document into its structural elements: titles, list items, tables, text, etc. By partitioning documents this way, you can avoid a situation where unrelated pieces of text end up in the same element, and then same chunk.",
    "Now, when you chunk the document elements with Unstructured, individual elements are already small so they will only be split if they exceed the desired maximum chunk size. Otherwise, they will remain as is. You can also optionally choose to combine consecutive text elements such as list items, for instance, that will together fit within chunk size limit.",
    "The chunks are ready for RAG. To use them with LangChain, you can easily convert Unstructured elements to LangChain documents.",
    "This example uses ChromaDB as a vector store and BAAI/bge-base-en-v1.5 embeddings model, feel free to use any other vector store.",
    "If you plan to use a gated model from the Hugging Face Hub, be it an embeddings or text generation model, you’ll need to authenticate yourself with your Hugging Face token, which you can get in your Hugging Face profile’s settings.",
    "Let’s bring everything together and build RAG with LangChain.\nIn this example we’ll be using Llama-3-8B-Instruct from Meta. To make sure it can run smoothly in the free T4 runtime from Google Colab, you’ll need to quantize it.",
    "Now that you have your RAG chain, let’s ask it about aphids. Are they a pest in my garden?",
    "Output:",
    "This looks like a promising start! Now that you know the basics of preprocessing complex unstructured data for RAG, you can continue improving upon this example. Here are some ideas:",
    "Have fun building RAG applications with Unstructured data!",
    ""
]