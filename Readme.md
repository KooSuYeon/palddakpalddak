# 🤖 RAG를 활용한 Sparta 복습용 챗봇 만들기

## 📖 목차
1. [How To Use](#-how-to-use)
2. [Directory Structure](#-directory-structure)
3. [Timeline](#-timeline)
4. [팀 소개 및 협업 도구](#-팀-소개-및-협업-도구)
5. [프로젝트 소개](#-프로젝트-소개)
6. [프로젝트 계기](#-프로젝트-계기)
7. [프로젝트 핵심 목표](#-프로젝트-핵심-목표)
8. [Key Summary](#️-key-summary)
9. [인프라 아키텍처 & 적용 기술](#-인프라-아키텍처-적용-기술)
10. [주요기능](#-주요기능)
11. [서비스 구조](#-서비스-구조)
12. [기술적 고도화](#-기술적-고도화)
---
## 📣 How To Use
```
- 사전에 공유된 구글 드라이브 링크에서 dataset 디렉터리를 다운로드 받아준 후 루트 디렉터리에 해당 디렉터리를 위치시켜 줍니다.
- .env 파일 생성 후  OPENAI_API_KEY, DEEPL_API_KEY, ELEVENLABS_API_KEY 환경 설정을 해줍니다.
- pip install -r requirements.txt 를 통해 개발 할 때 사용한 라이브러리와 버전을 맞춰줍니다.
- 터미널을 열어줍니다.
- 터미널에 프론트엔드 파일을 실행시켜줍니다.   
  streamlit run v2_Client_UI.py
```

---

## 🔍 Directory Structure

- 버전 관리가 필요한 파일들은 디렉터리 생성 후 넣어두었습니다.
- be, fe, rag_model : 백엔드, 프론트엔드, rag모델 버전 관리 (이전 버전)
- log: 백엔드 로그 관리
- rag_model_output : 사용자 채팅 관리

```
palddakpalddak/
├── __pycache__/
├── be/
│   ├── get_history_app.py
│   ├── get_specific_input.py
│   └── v0_API_server.py
├── fe/
│   ├── v1_fe.py
│   └── v2_fe.py
├── log/
│   └── UI.log
├── preProcessing/
│   ├── preProcessing.py # 실제 교재 전처리 코드
│   └── preProcessing_open_source # 실제 open_source 전처리 코드
├── rag_model/
│   ├── naive_rag_model.py
│   ├── v0_rag_chatbot.ipynb
│   ├── v1_rag_chatbot.ipynb
│   ├── v2_rag_chatbot.ipynb
│   ├── v3_rag_chatbot.ipynb
│   ├── v4_rag_chatbot.ipynb
│   └── v5_rag_chatbot.ipynb
├── rag_model_output/ # RAG 모델 구동 output 세션 별로 저장 파일 명의 형태, DB 처럼 관리 목적
    {user_id}_{session_no}_{type_}_{order}_quiz.txt
    {user_id}_{session_no}_{type_}_{order}_user.txt
    {user_id}_{session_no}_{type_}_{order}_feedback.txt
├── .gitignore
├── rag_model.py # API_server.py 와 연결된 RAG 모델
├── Readme.md
├── requirements.txt
├── st_ui_HSgoon.py
├── v1_API_server.py # 실제 BE
└── v1_Client_UI.py
└── v2_Client_UI.py # 실제 FE

```

---
## 🎢 Timeline
- [x] 11/21 챗봇 종류 정하기 및 데이터셋 범위 설정
- [x] 11/22 데이터셋 준비 & 전처리 완료
- [x] 11/27 대화 내용 저장 & RAG 1차 고도화 완료
- [x] 11/27 프론트엔드 채팅 화면 구현 완료
- [x] 11/27 백엔드 질문 전송, 답변 전송 구현 완료
- [x] 11/28 대화 내용을 구체적인 이름을 가진 txt 파일 저장으로 수정 완료 & RAG 2차 고도화 완료
- [x] 11/28 프론트엔드 옵션 선택 사이드 바 구현 완료 & 변경된 input값 적용 완료
- [x] 11/28 대화 저장 API 생성 완료 & 백엔드 수정된 input 값 적용 완료
- [x] 11/29 프론트엔드 user_id 로그인 화면 구현
- [x] 11/29 프론트엔드 세션 버튼 생성
- [x] 11/29 백엔드 세션 저장 API 연결
- [x] 11/29 RAG 모델에 이전 대화 내용 기억하는 기능 추가하기

---
## 🦾 팀 소개 및 협업 도구
- 팀명 : 팔딱팔딱
| 이름   | 역할                            |
|--------|---------------------------------|
| 구수연 | 팀장, AI 모델 개발, 데이터 수집, 대화세션 관리, 모델 성능개선 |
| 박성진 | 데이터 전처리, API, 데이터 수집, SA 문서, 서버 개발 |
| 윤수진 | Streamlit UI, 데이터 수집, 대화세션 관리 |
| 이현승 | Streamlit UI, 데이터 수집       |
| 김윤소 | AI 모델 개발, API, 데이터 수집  |
- 협업도구
   - GitHub
   - Jira
   - Slack
   - Notion
   - Figma
- 버전관리: Git (배포 X)


---
## 📋 프로젝트 소개
- 프로젝트명 : Sparta Review Helper
- 개발 기간 : 2024.11.21 - 2024.12.03

---
## 💡 프로젝트 계기
이번 스파르타 과정에서 저희가 배웠던 여러가지 내용들을 복습하는데 활용하는 AI 챗봇을 개발하면 유용할 것 같다는 생각에, 배운 자료들과 추가 오픈소스 등을 바탕으로 AI가 퀴즈를 내고 사용자가 정답을 입력하면 이에 대해 피드백해주는 학습용 AI 모델을 개발하게 되었습니다.

---
## ❕ 프로젝트 핵심 목표
저희 프로젝트의 목적은 부트캠프에서 배운 내용을 복습할 수 있는 퀴즈 챗봇을 구현하는 것입니다.
이 챗봇은 저희가 강의에서 배웠던 내용들을  학습하여, 내용을 퀴즈 형태로 제공하고, 유저의 답변에 대한 피드백을 제공하여 복습을 도와주고, 사용자의 흥미를 높일 수 있도록 설계되었습니다.

---
## 🗝️ Key Summary
- 챗봇 성능 고도화
   - RAG(Retrieval-Augmented Generation) 모델을 기반으로 사용자가 원하는 교재에 맞춘 질문 생성을 가능하게 하여 학습 효율성을 향상시켰습니다.
   - 기존에 특정 질문에만 연관된 결과가 반환되던 문제를 해결해 정확하고 연관성 높은 답변을 제공합니다.
- 주요 트러블 슈팅 사례
   - 챗봇이 유사한 질문을 계속 반복하는 경우
   - 데이터 전처리 과정에서 너무 많은 텍스트가 삭제되는 경우

---
## 🏠 인프라 아키텍처 & 적용 기술
- 아키텍처 구조
   - Frontend: Streamlit을 사용하여 직관적이고 간단한 사용자 인터페이스(UI)를 제공합니다.
   - Backend: FastAPI와 Python 기반으로 데이터 처리 및 API 호출을 담당합니다.
   - 데이터 관리: Chromadb를 활용해 문서 검색 및 질의응답에 최적화된 데이터베이스를 구축합니다.
- 적용 기술 및 이유
   - LangChain: RAG 모델과의 유기적 통합을 통해 효율적인 질문-응답 생성을 구현합니다.
   - Selenium + BeautifulSoup: 웹 데이터를 수집 및 전처리하고, 강의 자료를 활용할 수 있습니다.
   - OpenAI API: GPT 기반 언어 모델을 통해 사용자 친화적인 답변을 제공합니다.
   - GitHub, Slack, Jira, Notion: 협업 및 버전 관리 도구로 프로젝트의 생산성과 관리 효율성을 극대화합니다.

---
## 💬 주요기능
1. 퀴즈 생성 및 피드백 제공
   - 사이드바의 주제 및 교재 선택 기능을 통해 원하는 내용을 지정하고 QUIZ 시작 버튼을 누르면, AI가 관련된 퀴즈를 자동으로 생성합니다.
   - 사용자가 채팅으로 답변을 입력하면, AI는 답변에 대한 피드백을 제공합니다.
   - 추가적인 질문에 대해서도 AI가 대화를 이어가며 지속적으로 피드백을 제공합니다.
   - QUIZ 시작 버튼을 누를 때마다 중복되지 않는 새로운 퀴즈가 생성됩니다.
2. 언어 선택 기능
   - 언어 선택 버튼을 통해 원하는 언어를 선택하면, AI가 해당 언어로 답변을 생성합니다.
3. 음성 입력 및 피드백
   - AI가 퀴즈를 생성한 후, 사용자가 음성으로 답변을 입력하면, AI는 음성으로 피드백을 제공합니다.

이러한 기능을 통해 학습자는 다양한 방식으로 학습 내용을 복습하며 더욱 효과적으로 학습할 수 있습니다.

---
## 🗂️ 서비스 구조
1. 전체 흐름
   - 사용자가 사이드바에서 주제를 선택하고 QUIZ 시작 버튼을 클릭합니다.
   - AI 백엔드에서 선택한 주제와 교재에 맞는 퀴즈를 생성해 클라이언트로 전달합니다.
   - 사용자가 답변을 입력하면, AI가 백엔드에서 입력된 답변을 분석하고 피드백을 생성해 반환합니다.
   - 음성 모드에서는 음성 입력을 받아 텍스트로 변환하고, 다시 음성 피드백을 제공합니다.
2. 구성 요소
   - 프론트엔드
      - UI : 사이드바(주제/교재 선택, 언어 선택, 음성 녹음, 대화 내역), 채팅(대화 내용, 사용자 입력) 인터페이스로 구성되었습니다.
      - 사용자와 인터페이스 간의 상호작용 : 사용자의 선택 및 입력을 백엔드로 전달합니다.
   - 백엔드
      - 퀴즈 생성 모듈 : 강의 자료를 기반으로 적절한 퀴즈를 자동으로 생성합니다.
      - 답변 분석 및 피드백 생성 모듈 : 사용자 입력 데이터를 기반으로 피드백을 생성합니다.
   - 데이터베이스
      - 교재 및 강의 자료 파일을 저장합니다.
      - 생성된 퀴즈 기록, 사용자의 입력, 그에 기반한 피드백 데이터를 관리합니다.
3. 동작 예시
   -  사용자가 '머신러닝' 주제와 그와 관련된 교재를 선택한 후 `QUIZ 시작 버튼`을 통해 퀴즈를 요청 → AI가 QUIZ 생성 → 사용자가 답변 → AI가 피드백을 제공.

---
## 🛫 기술적 고도화
- 구수연
   <details>
   <summary>트러블 슈팅</summary>

      [성능 개선 / 코드 개선 요약]
      - 질문을 생성하는 챗봇이 유사한 질문을 계속해서 질문하는 경우
      [가설]
      - FAISS 기반 retriever가 항상 같은 질문만을 가져오는 경우
      [해결 방안]
      - cosine 유사도 비교로 유사한 질문을 생성해내는 경우에는 다른 질문을 생성하도록 했음
      - cosine 유사도는 단어의 유사도를 비교하는 것에 약점을 보였기 때문에 성능이 크게 좋아지지 않음 (실패)
      - 프롬프팅으로 고도화 시도 (성공)
      [해결 완료]
      - 프롬프트에 이전 질문을 넣어줌으로 llm에 명시적으로 과거의 질문과 겹치지 않도록 질문생성 유도하니 해결
      [회고]
      - 유사도의 메서드 사용 개념을 추가적으로도 검사하면 좋겠다고 생각해 후의 고도화에 TfidfVectorizer를 통한 벡터화를 진행 후 유사도 비교를 진행하였습니다.
      - 해당 유사도 비교로는 성능 개선을 보였고 특정 횟수 (10번)을 넘어간다면 질문을 생성하지 않는 출제 방식으로 수정하여 교재에 대해 질문의 range가 다 찼을 경우도 적용해 볼 수 있는 기회가 되었습니다.

   </div>
   </details>

- 윤수진
   <details>
   <summary>핵심 성능 개선</summary>

      [내가 구현한 기능]
      - 로그인과 채팅 페이지 분리 : 로그인 페이지와 채팅 페이지를 UI 단에서 분리하여 사용자가 로그인하면 채팅 페이지에 접근할 수 있습니다.
      - 세션 관리 : 사이드바의 버튼으로 대화 세션을 구분해 세션별로 대화 내역을 확인할 수 있습니다.
      [주요 로직]
      - 로그인 페이지와 채팅 페이지 분리
         st.session_state.page 값에 따라 login_page() 함수나 chat_page() 함수를 실행하여 로그인 페이지 또는 채팅 페이지를 보여줍니다.
      - 세션 관리
         - 대화 기록이 존재하는 지 여부를 확인하여, 대화 기록이 없으면 "진행중인 대화가 없습니다."라는 메시지를 표시합니다.
         - 대화 기록이 존재하는 경우, ChatID를 기준으로 대화 기록을 구분하며 각 대화 ID에 대해 사이드바에 버튼을 생성합니다.
            사용자가 버튼을 클릭하면 클릭된 버튼에 연결된 ChatID와 일치하는 대화 기록만 필터링하여 대화 내역을 로드합니다.
      [배경]
      - 한 대화에서 사용자의 입력만큼 버튼이 생성되어 사이드바의 내용이 불필요하게 길어졌습니다.
      - 챗봇의 추가적인 기능을 구현하기 위해, 로그인 페이지와 채팅 페이지를 분리할 필요가 있었습니다.
      [요구사항]
      - 로그인 시 채팅 페이지로 이동하고, 새로고침하면 로그인 페이지가 로드되도록 해야 합니다.
      - 하나의 대화 세션에 하나의 버튼만 생성되어야 합니다.

   </div>
   </details>

   <details>
   <summary>트러블 슈팅</summary>

      [성능 개선 / 코드 개선 요약]
      - get_button_label 함수에서 발생한 IndexError를 해결하기 위해서 예외 처리를 추가하여 코드의 안정성을 개선했습니다.
      - "User" 메시지가 없을 때 발생할 수 있는 오류를 방지하고, 메시지를 통해 사용자에게 피드백을 제공하게 했습니다.
      [문제 정의]
      - get_button_label 함수 수정 중 IndexError가 발생했습니다.
      [가설]
      - 데이터에서 "User" 메시지를 탐색할 때, 대소문자가 다르거나 메시지가 없는 경우가 원인일 수 있었습니다.
      [해결 방안]
      - 코드 수정
         "User" 대신 "user"로 대소문자를 수정하여 데이터 키와 일치하도록 변경했습니다.
         예외 처리를 추가하여 User 메시지가 없는 경우에도 안정적으로 작동하도록 구현했습니다.
      - 예외 처리
         User 메시지가 없을 경우 "No User message found"라는 기본 메시지를 반환하도록 설정했습니다.
      [해결 완료]
      - IndexError 발생 없이 버튼 레이블이 정상적으로 출력되었습니다.
      - User 메시지가 없을 경우에도 "No User message found" 메시지가 출력되었습니다.
      [회고]
      - 기술의 장단점 : 대소문자 불일치와 예외 상황을 모두 처리하여 코드 안정성을 향상시켰습니다. 그러나 대소문자만 수정했기 때문에 데이터가 달라지면 이 값도 수정해야 합니다.
      - 다시 시도한다면? : 처음부터 데이터 구조를 정확하게 파악하고, 이를 기반으로 코드를 설계할 것입니다. 코드 작성 시 예외 처리와 데이터 유효성 검사에 더 신경 써서, 예상치 못한 오류가 발생하지 않도록 철저하게 준비할 것입니다. 또한, 코드 작성 후에는 충분한 테스트를 통해 다양한 경우의 수를 체크하여 안정성을 높일 것입니다.

   </div>
   </details>